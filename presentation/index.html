<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>Electron.js</title>
  <link rel="shortcut icon" href="assets/electronjs-icon.svg" type="image/x-icon">

  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="dist/theme/black.css">
  <link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <a href="https://www.electronjs.org/">
          <img src="assets/electronjs-icon.svg" alt="" height="200px">
        </a>
        <h1>Electron.js</h1>
        <a href="https://www.electronjs.org/" target="_blank"><small>electronjs.org</small></a>
        <aside class="notes">
          The topic of my presentation is Electron.js
        </aside>
      </section>

      <section>
        <h3>What is Electron.js?</h3>
        <div class="fragment fade-in" data-id="box" style="
					border-left: 5px solid #9EE9F8;
					padding-left: 20px;
					padding-right: 50px;
					text-align: justify;
				">
          Framework for building desktop applications using JavaScript, HTML, and CSS.
        </div>
        <div class="fragment fade-in" data-id="box" style="
				margin-top: 30px;
				border-left: 5px solid #9EE9F8;
				padding-left: 20px;
				padding-right: 50px;
				text-align: justify;
			">
          It’s an open source project started by Cheng Zhao, an engineer at GitHub.
        </div>

        <aside class="notes" data-markdown>
          ## 2 slide: What is Electron.js?

          Electron.js is framework for building desktop applications using JavaScript, HTML, and CSS.
          It allows you to use the web technologies you already know to build cross-platform applications.

          Electron.js is an open source project started by engineer at GitHub.
          Previously called Atom Shell, it is the foundation for Atom, a cross-platform text editor by GitHub built with
          web technologies.
        </aside>
      </section>

      <section>
        <h3>Applications based on Electron.js</h3>
        <div class="r-hstack justify-center">
          <div class="fragment fade-up" style="width: 100px; height: 100px; margin: 10px;">
            <img src="assets/slack-icon.svg" alt="">
          </div>
          <div class="fragment fade-up" style="width: 100px; height: 100px; margin: 10px;">
            <img src="assets/twitch-icon.svg" alt="">
          </div>
          <div class="fragment fade-up" style="width: 100px; height: 100px; margin: 10px;">
            <img src="assets/vscode-icon.svg" alt="">
          </div>
          <div class="fragment fade-up" style="width: 100px; height: 100px; margin: 10px; border-radius: 5px;">
            <img src="assets/whatsapp-icon.svg" alt="">
          </div>
        </div>


        <div class="electron-applications r-hstack justify-center"
          style="flex-wrap: wrap; max-width: 900px; min-height: 200px; margin: 10px auto;">
        </div>
        <div style="margin-top: 40px;">
          <small><a href="https://www.electronjs.org/apps">All applications</a></small>
        </div>

        <aside class="notes" data-markdown>
          ## 3 slide: Applications based on electron.js

          I think that many people know the desktop versions of these applications. All of them are based on
          Electron.js.
          Slack, Twitch, Visual Studio Code, WhatsApp, Figma, Google Assistant, Discord...

          This list can be continued for a very long time, because more than 700 applications are built on the
          framework, which can be found on the official site
        </aside>
      </section>

      <section>
        <section data-background="https://media.giphy.com/media/tIeCLkB8geYtW/giphy.gif">
          <h3>Advantages</h3>

          <aside class="notes" data-markdown>
            ## 4 slide: advantages and disadvantages
            This framework has many strengths
          </aside>
        </section>

        <section>
          <h3 style="margin-bottom: 50px;">For business</h3>
          <ul>
            <li class="fragment fade-in">
              Simple way to create cross-platform applications
            </li>
            <li class="fragment fade-in">
              Creating a desktop application for an existing web application
            </li>
            <li class="fragment fade-in">
              Cheaper and faster to develop
            </li>
          </ul>

          <aside class="notes" data-markdown>
            ### 4.1 (5): for business

            First of all, Electron.js has a number of advantages over native development for the customer of the
            application.

            - Electron.js is simple way to create cross-platform applications.
            It is capable of integrating one code to all platforms, which significantly speeds up the development
            process.

            - Also, having already a web application, you will not need a lot of time and effort to rewrite it to
            desktop using Electron.
            Thus, it is possible to ensure the release of the application on the web and desktop platform.

            - Application development on electron.js is cheaper and faster than native development
            Since one language for all platforms will speed up the release of the product and reduce the number of
            people in the team
          </aside>
        </section>

        <section>
          <h3 style="margin-bottom: 50px;">For developers</h3>
          <ul>
            <li class="fragment fade-up">One code for Windows, macOS, and Linux.</li>
            <li class="fragment fade-up">Easy to test</li>
            <li class="fragment fade-up">One programming language</li>
          </ul>
          <aside class="notes" data-markdown>
            ### 4.2 (6): for developer

            There are a number of advantages in the process of developing applications based on Electron.js .

            - building desktop applications for multiple platforms, Electron is a great way to build your product
            without the hassle
            of managing two or three distinct code bases, squashing related bugs on two or three platforms, or
            implementing the same feature two or three times

            - Besides, no multiple tests are required to ensure that each app contains identical features. Since the
            whole work is done in a separate code base, QA engineers can fix the issue within, wherever it appears.
            Therefore, the development time goes down.

            - Electron allows you to maintain one JavaScript codebase and create cross-platform apps that work on
            Windows, macOS, and Linux — no native development experience required.

            With Electron, you can use your existing skills as a web developer to build applications that have many of
            the capabilities of a native desktop application.

            Electron is great for individuals or small teams who may want to target more
            than one platform without having to learn three or more languages, as well as
            each platform’s frameworks.
          </aside>
        </section>

        <section>
          <h3>Superiority over web applications</h3>
          <ul>
            <li class="fragment fade-up">Access the filesystem and operating system APIs</li>
            <li class="fragment fade-up">Does not require an internet connection</li>
            <li class="fragment fade-up">Enhanced privileges and looser restrictions</li>
          </ul>

          <aside class="notes" data-markdown>
            ## 7 slide: Superiority over web applications

            There are many reasons why a desktop application is superior to a web application.

            - Traditional browser applications can’t access the filesystem.
            Electron applications can access operating system APIs such as application and
            context menus, File Open and Save dialog boxes, battery status and power settings,
            and more.

            - Most web applications aren’t available when there isn’t a reliable internet connection.
            Even advanced web applications using any of the popular client-side frameworks
            like React, or Angular typically need to connect to a remote server to download their assets.
            Electron applications have already been downloaded to the user’s computer. Typically, they load a locally
            stored HTML file. From there, they can request remote data and assets if a connection is available. Electron
            even provides APIs that allow you to detect if a connection is available.

            - Desktop applications enjoy a wider range of abilities and fewer restrictions on what
            they’re allowed to do because the user explicitly went out of their way to download,
            install, and open the application. When you’re browsing the web, however, you don’t
            have the same amount of agency. You’re executing code that you didn’t choose to
            install on your computer. As a result, web applications have many limits on what
            they’re allowed to do.

            Unlike traditional web applications, Electron applications aren’t limited to the browser.
            You can create applications that live in the menu bar or the system tray.
            You can even register global shortcuts to trigger these applications or any of their abilities
            with a special keystroke from anywhere in the operating system.
            Electron applications have access to system-level information—such as whether the computer is on battery
            power or plugged into the wall. They can also keep the operating
            system awake and prevent it from going into power-saving mode, if necessary.
          </aside>
        </section>
      </section>

      <section>
        <section data-background="https://media.giphy.com/media/27EhcDHnlkw1O/giphy.gif">
          <h3>Disadvantages</h3>
          <aside class="notes" data-markdown>
            Hybrid and native development are always one of the hottest disputes related to the weaknesses of
            Electron-based applications.
          </aside>
        </section>
        <section>
          <ul>
            <li class="fragment fade-up">Large size</li>
            <li class="fragment fade-up">Resources grabbing</li>
            <li class="fragment fade-up">Specific requirements</li>
          </ul>
          <aside class="notes" data-markdown>
            The most important disadvantage is the large (compared to other technologies)
            memory consumption: an empty project takes up 100-200 megabytes in memory. For some, this is a reason to
            stop
            using such applications.

            This is because Chromium browser (codebase for web browser) is large software including many code lines. As
            a result, your app will convert into one large block that takes a tidbit of your hard drive.

            Besides operative memory, Electron-based products occupy system reserves and utilize plenty of laptops’
            battery energy. The reason is that such applications are optimized for different platforms, thus, energy
            inefficient. In contrast, native applications are made for a particular platform, so their reserves are
            streamlined effectively.

            Developers have to face difficulties when implementing platform-specific requirements. Best-case scenario,
            all cross-platform apps should operate identically on all OS. However, if clients want to add unique
            features for each platform, it will lead to some difficulties concerning product development. Firstly, it
            will take some time to realize those features. Secondly, increased time leads to additional expenses. Take
            any Electron-based app like Slack or WhatsUp. It looks the same on any operating system.

            This is both an advantage and a disadvantage of Electon.js.
            It is worth carefully studying the weaknesses of the framework before you start writing an application on
            it, in order to avoid trouble.
          </aside>
        </section>
      </section>

      <section>
        <section>
          <h3>How it work?</h3>
          <aside class="notes">Let's have a look at how the electron works</aside>
        </section>

        <section>
          <table>
            <tr>
              <th style="text-align: center;" class="fragment highlight-blue">
                Chromium
              </th>
              <th style="text-align: center;" class="fragment highlight-purple">
                Node.js
              </th>
            </tr>
            <tr>
              <td style="text-align: center;">
                <ul>
                  <li>Rendering HTML
                    and CSS</li>
                  <li>Document Object
                    Model (DOM)</li>
                  <li>Web APIs</li>
                </ul>
              </td>
              <td style="text-align: center;">
                <ul>
                  <li>Filesystem access</li>
                  <li>Support for compiled modules</li>
                  <li>CommonJS Module</li>
                </ul>
              </td>
            </tr>
          </table>

          <aside class="notes" data-markdown>
            ## 10 slide: Chromium + Node.js

            Electron combines the core web browsing component of Chromium Content Module with the low-level system
            access of Node.

            Chromium is the open source version of Google’s Chrome web browser. The Content Module is the core code that
            allows Chromium to render web pages in independent processes and use web apis.

            The Node.js project is cross-platform runtime for developing server-side applications using JavaScript

            Chromium and Node are both wildly popular application platforms in their own
            right, and both have been used independently to create ambitious applications.

            Electron brings the two platforms together to allow you to use JavaScript to build an entirely new class of
            application. Anything you can do in the browser, you can do with
            Electron. Anything you can do with Node, you can do with Electron.
          </aside>
        </section>
        <section>
          <h3>Electron.js app architecture</h3>
          <img src="assets/schema.svg" alt="">
          <aside class="notes" data-markdown>
            Electron applications consist of two types of processes: the main process and zero or more renderer
            processes. Each process plays a different role in the application. The Electron runtime includes different
            modules to assist you in building your application.
            Certain modules, such as the ability to read and write from the system’s clipboard, are available in both
            types of processes. Others, such as the ability to access an operating
            system’s APIs, are limited to the main process.
          </aside>
        </section>


        <section>
          <table>
            <tr>
              <th style="text-align: center;" class="fragment highlight-purple">
                Main process
              </th>
              <th style="text-align: center;" class="fragment highlight-blue">
                Render processes
              </th>
            </tr>
            <tr>
              <td style="text-align: center;">
                <ul>
                  <li>Handles OS integration</li>
                  <li>Manages the lifecycle of the application</li>
                  <li>Creates renderer processes</li>
                </ul>
              </td>
              <td style="text-align: center;">
                <ul>
                  <li>display the UI</li>
                  <li>respond to user events</li>
                </ul>
              </td>
            </tr>
          </table>
          <aside class="notes" data-markdown>
            Main

            The main process handles OS integration, manages the lifecycle of the application,
            and creates renderer processes.

            The main process has a few important responsibilities. It can respond to application lifecycle events such
            as starting up, quitting, preparing to quit, going to the background,
            coming to the foreground, and more. The main process is also responsible for communicating to native
            operating system APIs. If you

            Renderer

            Renderer processes display the UI and respond to user events.

            The main process can create and destroy renderer processes using Electron’s Browser-
            Window module. Renderer processes can load web pages to display a GUI. Each process
            takes advantage of Chromium’s multiprocess architecture and runs on its own thread.
            These pages can then load in additional JavaScript files and execute code in this process.
            Unlike normal web pages, you have access to all the Node APIs in your renderer
            processes, allowing you to use native modules and lower-level system interactions.
            Renderer processes are isolated from each other and unable to access operating
            system integration APIs. Electron includes the ability to facilitate communication
            between processes to allow renderer processes to communicate with the main process
            in the event that they need to trigger an Open or Save File dialog box or access any
            other OS-level integration.
          </aside>
        </section>

        <section>
          <h2>
            Thank you for your attention!
          </h2>
        </section>
      </section>
    </div>
  </div>

  <script src="dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
      hash: true,

      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });

    Reveal.configure({
      keyboard: {
        90: appAnimation,
      }
    });

    const apps = [
      'assets/figma-icon.svg',
      'assets/discord-icon.svg',
      'assets/google-assistant-icon.png',
      'assets/taskade-icon.webp',
      'assets/avocode-icon.svg',
      'assets/facebook-icon.svg',
      'assets/atom-icon.svg',
      'assets/vk-desktop-icon.svg',
      // 'assets/smallpdf-icon.png',
      'assets/notion-icon.svg',
      'assets/skype-icon.svg'
    ];
    function appAnimation() {
      const appsRoot = document.querySelector('.electron-applications');
      appsRoot.style.overflow = 'hidden';

      apps.forEach((app, idx) => {
        setTimeout(() => {
          const img = document.createElement('img');
          img.src = app;
          img.onload = () => {
            appsRoot.innerHTML += `<img src="${app}" style="width: 100px; height: 100px; margin: 20px 10px" alt="">`
          }
        }, idx * 300);
      });
    }
  </script>
</body>

</html>